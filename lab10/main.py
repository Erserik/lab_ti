# Ширина входного информационного символа (бит)
SYM_WIDE = 8
# Входные данные (информационное слово)
DATAIN = 0x69  # Данные для передачи
# Номер искажаемого бита
ERR_POS = 3
# Генераторный полином
MAG = (1 << (SYM_WIDE * 1)) + (1 << (SYM_WIDE * 0))

# Таблица степеней двойки для поиска позиции ошибки
pow_table = [1, 2, 4, 8, 16, 32, 64, 128, 256]

# Поиск позиции ошибки по остатку
def lockup(x):
    for a in range(9):
        if pow_table[a] == x:
            return a
    return -1

def main():

    # Кодирование: умножение данных на генераторный полином
    c = DATAIN * MAG
    print(f"i = {DATAIN:08x} (DATAIN)\ng = {MAG:08x} (ПОЛИНОМ)")
    print(f"c = {c:08x} (КОДОВОЕ СЛОВО)")

    # Введение ошибки в указанный бит
    e = c ^ (1 << ERR_POS)
    print(f"e = {e:08x} (ПОЛУЧЕННЫЕ ДАННЫЕ+ОШИБКА)\n")

    # Проверка и исправление ошибки
    if e % MAG != 0:
        print(f"Декодер Рида-Соломона сообщает: ({e % MAG:x}) ошибка обнаружена\n{{")
        k = e % MAG
        print(f"\tПозиция ошибки: {lockup(k):x}")
        e ^= k  # Исправление ошибки
        print(f"\tВосстановленное кодовое слово: {e:x}\n}}")

    # Полученные данные после декодирования
    print(f"ПОЛУЧЕННЫЕ ДАННЫЕ: {e // MAG:x}")

if __name__ == "__main__":
    main()

